
# 객체와 참조

## 가변/불변 객체 개념
### 1. Mutable(가변) 객체 : 생성 후 내용을 변경할 수 있는 객체
	- 예: `list`, `dict`, `set`
### 2. Immutable(불변) : 생성 후 내용을 변경할 수 없는 객체
	- 예: `int`, `float`, `str`, `tuple`

## 변수 할당의 의미
파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정이다.
- 변수는 객체의 메모리 주소를 가리키는 Label 역할을 한다.
- `=` 연산자를 사용하여 변수에 값을 할당한다.
- 할당 시 새로운 객체가 생성되거나 기본 객체에 대한 참조가 생성된다.

## 메모리 참조 방식
- 변수는 객체의 '메모리 주소'를 저장한다.
- 여러 변수가 동일한 객체를 참조할 수 있다.

## 가변 객체 예시
```python
a = [1, 2, 3, 4]
b = a
b[0] = 100

print(f'a의 값: {a}')  # [100, 2, 3, 4]
print(f'b의 값: {b}')  # [100, 2, 3, 4]
print(f'a와 b가 같은 객체를 참조하는가? {a is b}')  # True
```
- a가 가진 '메모리 주소'를 b에 할당한 것
- 즉, a와 b는 같은 객체의 메모리 주소를 참조하고 있다. (a와 b의 요소까지도)

## 불변 객체 예시
```python
a = 20
b = a
b = 10

print(f'a의 값: {a}')  # 20
print(f'b의 값: {b}')  # 10
print(a is b)  # False
```
- 마찬가지로 a가 가진 '메모리 주소'를 b에 할당
- 그러나 b에 10을 재할당하면서 서로 다른 객체의 메모리 주소를 참조하게 됨

## `id()` 함수를 사용한 메모리 주소 확인
```python
x = [1, 2, 3]
y = x
z = [1, 2, 3]

print(f'x의 id: {id(x)}') # 1704481686720
print(f'y의 id: {id(y)}') # 1704481686720
print(f'z의 id: {id(z)}') # 1704481717376
print(f'x와 y는 같은 객체인가? {x is y}') # True
print(f'x와 z는 같은 객체인가? {x is z}') # False
```
- `id()` 함수를 사용하여 객체의 메모리 주소를 확인 가능하다.
- `is` 연산자를 통해 두 변수가 같은 개게를 참조하는지 확인 가능하다.

## 가변/불변 메모리 관리 방식
- 가변 객체는 생성 후에도 그 내용을 수정할 수 있으며 객체의 내용이 변경되어도 같은 메모리 주소를 유지한다.
- 불변 객체는 생성 후 그 값을 변경할 수 없으며 새로운 값을 할당하면 새로운 객체가 생성되고, 변수는 새 객체를 참조하게 된다.

## 이러한 동작 방식의 이유
- 성능 최적화 : 불변 객체는 변경이 불가능하므로 여러 변수가 같은 객체를 안정하게 공유할 수 있으며, 가변 객체는 내용 수정이 빈번한 경우 새 객체를 생성하지 않고 직접 수정하여 성능을 향상시킨다.

- 메모리 효율성 : 불변 객체는 동일한 값을 가진 여러 객체가 메모리를 공유할 수 있어 효율적이며, 가변 객체는 크기가 큰 데이터를 효율적으로 수정할 수 있다.

 # 얕은 복사(Shallow Copy)
객체의 **최상위 요소**만 새로운 메모리에 복사하는 방법으로 내부에 중첩된 객체가 있다면 그 객체의 참조만 복사된다.

## 얕은 복사 구현 방법
1. 리스트 슬라이싱
2. `copy()` 메서드
3. `list()` 함수
```python
a = [1, 2, 3]

b = a[:]  # 슬라이싱
c = a.copy()  # copy() 메서드
d = list(a)  # list() 함수

b[0] = 100
c[0] = 999
d[0] = 8080

print(a)  # [1, 2, 3]
print(b)  # [100, 2, 3]
print(c)  # [999, 2, 3]
print(d)  # [8080, 2, 3]
```

## 얕은 복사의 한계
2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우
```python
a = [1, 2, [3, 4, 5]]
b = a[:]

b[0] = 999
print(a)  # [1, 2, [3, 4, 5]]
print(b)  # [999, 2, [3, 4, 5]]

b[2][1] = 100
print(a)  # [1, 2, [3, 100, 5]]
print(b)  # [999, 2, [3, 100, 5]]
print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}')  # True
```
- a와 b의 주소는 다르지만 내부 객체의 주소는 같기 때문에 함께 변경된다.
- 따라서 1차원 리스트의 경우 얕은 복사로도 충분히 독립적인 복사본을 만들 수 있으나,
- 다차원 리스트의 경우 최상위 리스트만 복사되고, 내부 리스트는 여전히 원본과 같은 객체를 참조한다.

# 깊은 복사(Deep Copy)
객체의 **모든 수준의 요소**를 **새로운 메모리**에 복사하는 방법으로 **중첩된 객체까지 모두** 새로운 객체로 생성된다.

## 깊은 복사 하는 방법
`copy` 모듈에서 제공하는 `deepcopy()` 함수를 사용한다.
```python
import copy

new_object = copy.deepcopy(original_object)
```

## 깊은 복사 예시
```python
import copy

a = [1, 2, [3, 4, 5]]
b = copy.deepcopy(a)

b[2][1] = 100
print(a)  # [1, 2, [3, 4, 5]]
print(b)  # [1, 2, [3, 100, 5]]
print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}')  # False
```
## 중첩된 객체에서의 깊은 복사
```python
original = {
    'a': [1, 2, 3],
    'b': {
        'c': 4,
        'd': [5, 6],
    },
}
copied = copy.deepcopy(original)

copied['a'][1] = 100
copied['b']['d'][0] = 500

print(f'원본: {original}')  # {'a': [1, 2, 3], 'b': {'c': 4, 'd': [5, 6]}}
print(f'복사본: {copied}')  # {'a': [1, 100, 3], 'b': {'c': 4, 'd': [500, 6]}}
print(
    f'original["b"]와 copied["b"]가 같은 객체인가? {original["b"] is copied["b"]}'
)  # False
```
